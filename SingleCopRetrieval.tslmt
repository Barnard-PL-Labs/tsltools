#LIA  
initially assume { 

}


always assume {
    MinX() <= Cop.x;
    Cop.x <= MaxX();
    
    MinY() <= Cop.y;
    Cop.y <= MaxY();  

    !(Cop.x = MinX() && Cop.x = MaxX());

    !(Cop.y = MinY() && Cop.y = MaxY());


    Cop.x = MinX()  && !([Cop.x <- Cop.x + 1] || [Cop.x <- Cop.x - 1]) ->  X (Cop.x = MinX());
    Cop.x = MaxX()  && !([Cop.x <- Cop.x + 1] || [Cop.x <- Cop.x - 1]) ->  X (Cop.x = MaxX());
    Cop.y = MinY()  && !([Cop.y <- Cop.y + 1] || [Cop.y <- Cop.y - 1]) ->  X (Cop.y = MinY());
    Cop.y = MaxY()  && !([Cop.y <- Cop.y + 1] || [Cop.y <- Cop.y - 1]) ->  X (Cop.y = MaxY());


    !(Cop.x = MaxX()) && ([Cop.x <- Cop.x + 1]  W (Cop.x = MaxX())) -> F(Cop.x = MaxX());
    !(Cop.x = MinX())  && ([Cop.x <- Cop.x - 1]  W (Cop.x = MinX()))  -> F(Cop.x = MinX());

    !(Cop.y = MaxY()) && ([Cop.y <- Cop.y + 1]  W (Cop.y = MaxY())) -> F(Cop.y = MaxY());
    !(Cop.y = MinY())  && ([Cop.y <- Cop.y - 1] W (Cop.y = MinY()))  -> F(Cop.y = MinY());




}

always guarantee {


  ([Cop.x <- Cop.x + 1] || [Cop.x <- Cop.x - 1] || [Cop.x <- Cop.x]);
  ([Cop.y <- Cop.y + 1] || [Cop.y <- Cop.y - 1] || [Cop.y <- Cop.y]);
  

  !([Cop.x <- Cop.x] && [Cop.y <- Cop.y]);

  (Cop.x = MinX()) -> !([Cop.x <- Cop.x - 1]) W !(Cop.x = MinX());

  (Cop.x = MaxX()) -> !([Cop.x <- Cop.x + 1]) W !(Cop.x = MaxX());

  (Cop.y = MinY()) -> !([Cop.y <- Cop.y - 1]) W !(Cop.y = MinY());

  (Cop.y = MaxY()) -> !([Cop.y <- Cop.y + 1]) W !(Cop.y = MaxY());

  F (Cop.x = MaxX() && Cop.y = MinY());
  F (Cop.x = MinX() && Cop.y = MinY());
  F (Cop.x = MaxX() && Cop.y = MaxY());
  F (Cop.x = MinX() && Cop.y = MaxY());


}