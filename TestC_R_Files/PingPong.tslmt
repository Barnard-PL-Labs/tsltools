#LIA  
initially assume { 
}

always assume {
    (MinX() < MaxX());
    (MinY() < MaxY());   

    ! (Cop.x = MinX() && Cop.x = MaxX());
    ! (Cop.x = MinY() && Cop.y = MaxY());




    [Cop.x <- Cop.x + 1] -> X(!(Cop.x = MinX()));
    [Cop.x <- Cop.x - 1] -> X(!(Cop.x = MaxX()));

    [Cop.y <- Cop.y + 1] -> X(!(Cop.y = MinY()));
    [Cop.y <- Cop.y - 1] -> X(!(Cop.y = MaxY()));


}

always guarantee {

  //Cop.x maxX eventually cop.x minX and inverse
  (Cop.x = MaxX()) -> F [Cop.x <- Cop.x - 1];
  (Cop.x = MinX()) -> F [Cop.x <- Cop.x + 1];

  (Cop.y = MaxY()) -> F [Cop.y <- Cop.y - 1];
  (Cop.y = MinY()) -> F [Cop.y <- Cop.y + 1];

  [Cop.x <- Cop.x + 1] || [Cop.x <- Cop.x - 1];

  [Cop.y <- Cop.y + 1] || [Cop.y <- Cop.y - 1];

  (! (Cop.x = MinX()) && ! (Cop.x = MaxX())) -> F ([Cop.x <- Cop.x + 1] || [Cop.x <- Cop.x - 1]);
  (! (Cop.y = MinY()) && ! (Cop.y = MaxY())) -> F ([Cop.y <- Cop.y + 1] || [Cop.y <- Cop.y - 1]);



 // X Coordinate Ping Pong Effects
  (Cop.x = MinX() && X (!(Cop.x = MinX()))) -> ((! [Cop.x <- Cop.x - 1]) W (Cop.x = MaxX()));
  (Cop.x = MaxX() && X (!(Cop.x = MaxX()))) -> ((! [Cop.x <- Cop.x + 1]) W (Cop.x = MinX()));

  (Cop.y = MinY() && X (!(Cop.y = MinY()))) -> ((! [Cop.y <- Cop.y - 1]) W (Cop.y = MaxY()));
  (Cop.y = MaxY() && X (!(Cop.y = MaxY()))) -> ((! [Cop.y <- Cop.y + 1]) W (Cop.y = MinY()));
 // Neither X min or max, do something





}